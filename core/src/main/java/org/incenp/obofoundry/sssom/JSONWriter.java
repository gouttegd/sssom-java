/*
 * SSSOM-Java - SSSOM library for Java
 * Copyright © 2024 Damien Goutte-Gattat
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the Gnu General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package org.incenp.obofoundry.sssom;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.incenp.obofoundry.sssom.model.ExtensionDefinition;
import org.incenp.obofoundry.sssom.model.ExtensionValue;
import org.incenp.obofoundry.sssom.model.Mapping;
import org.incenp.obofoundry.sssom.model.MappingSet;
import org.incenp.obofoundry.sssom.model.ValueType;

/**
 * A writer to serialise a SSSOM mapping set into a JSON format.
 * <p>
 * The JSON format generated by this writer is <em>not</em> the JSON format used
 * by SSSOM-Py! SSSOM-Py uses a JSON-LD format that, for now, is completely
 * unspecified. Instead, this writer produces a “pure” JSON format that is
 * merely a direct JSON rendering of the internal SSSOM data model.
 */
public class JSONWriter {

    private Writer writer;
    private StringBuilder buffer = new StringBuilder();
    private int indentLevel = 0;
    private boolean firstItem = false;
    private ExtensionSlotManager extensionManager;
    private ExtraMetadataPolicy extraPolicy = ExtraMetadataPolicy.NONE;
    private PropagationPolicy condensationPolicy = PropagationPolicy.Disabled;

    /**
     * Creates a new instance that will write data to the specified file.
     * 
     * @param file The file to write the mapping set to.
     * @throws IOException If the file cannot be opened for any reason.
     */
    public JSONWriter(File file) throws IOException {
        writer = new FileWriter(file);
    }

    /**
     * Creates a new instance that will write data to the specified stream.
     * 
     * @param stream The stream to write the mapping set to.
     */
    public JSONWriter(OutputStream stream) {
        writer = new OutputStreamWriter(stream);
    }

    /**
     * Creates a new instance that will write data to a file with the specified
     * filename.
     * 
     * @param filename The name of the file to write the mapping set to.
     * @throws IOException If the file cannot be opened for any reason.
     */
    public JSONWriter(String filename) throws IOException {
        writer = new FileWriter(new File(filename));
    }

    /**
     * Sets the policy to deal with non-standard metadata in the mapping set to
     * write.
     * 
     * @param policy The policy instructing the writer about what to do with any
     *               non-standard metadata. The default policy is
     *               {@link ExtraMetadataPolicy#NONE}, meaning that no non-standard
     *               metadata is ever written.
     */
    public void setExtraMetadataPolicy(ExtraMetadataPolicy policy) {
        extraPolicy = policy;
    }

    /**
     * Enables or disables the condensation of "propagatable slots".
     * 
     * @param enabled {@code True} to enable condensation; it is enabled by default.
     */
    public void setCondensationEnabled(boolean enabled) {
        condensationPolicy = enabled ? PropagationPolicy.NeverReplace : PropagationPolicy.Disabled;
    }

    /**
     * Serialises a mapping set into the underlying file.
     * 
     * @param mappingSet The mapping set to serialise.
     * @throws IOException If an I/O error occurs.
     */
    public void write(MappingSet mappingSet) throws IOException {

        // Compute effective definitions for non-standard slots
        extensionManager = new ExtensionSlotManager(ExtraMetadataPolicy.DEFINED, new PrefixManager());
        extensionManager.fillFromExistingExtensions(mappingSet);
        mappingSet.setExtensionDefinitions(extensionManager.getDefinitions(true, false));

        // Condense the set
        Set<String> condensedSlots = new SlotPropagator(condensationPolicy).condense(mappingSet, true);

        // Write the metadata
        startDict();
        SlotVisitor<MappingSet> visitor = new SlotVisitor<MappingSet>();
        SlotHelper.getMappingSetHelper().visitSlots(mappingSet, visitor);
        writer.append(buffer.toString());
        buffer.delete(0, buffer.length());

        // Write the mappings
        addKey("mappings");
        startList();
        SlotHelper<Mapping> helper = SlotHelper.getMappingHelper(true);
        helper.excludeSlots(condensedSlots);
        SlotVisitor<Mapping> vm = new SlotVisitor<Mapping>();
        for ( Mapping m : mappingSet.getMappings() ) {
            addItem();
            startDict();
            helper.visitSlots(m, vm);
            endDict();

            writer.append(buffer.toString());
            buffer.delete(0, buffer.length());
        }
        endList();

        endDict();

        writer.append(buffer.toString());
        writer.append('\n');
        writer.close();
    }

    /* Starts writing a JSON dictionary. */
    private void startDict() {
        buffer.append("{");
        indentLevel += 1;
        firstItem = true;
    }

    /* Appends a new key in a JSON dictionary. */
    private void addKey(String key) {
        if ( !firstItem ) {
            buffer.append(',');
        }
        buffer.append('\n');
        buffer.append("  ".repeat(indentLevel));
        buffer.append('"');
        buffer.append(key);
        buffer.append("\": ");
        firstItem = false;
    }

    /* Appends a string value to the JSON flow. */
    private void addValue(String value) {
        buffer.append('"');
        // Escaping string value according to JSON rules
        // (https://www.ietf.org/rfc/rfc4627.html#section-2.5)
        for ( int i = 0, n = value.length(); i < n; i++ ) {
            int c = value.codePointAt(i);
            switch ( c ) {
            case '"':
            case '\\':
                buffer.append('\\');
                buffer.appendCodePoint(c);
                break;

            case 0x08: // Backspace
                buffer.append("\\b");
                break;

            case 0x09: // Horizontal tab
                buffer.append("\\t");
                break;

            case 0x0A: // Line feed
                buffer.append("\\n");
                break;

            case 0x0C: // Form feed
                buffer.append("\\f");
                break;

            case 0x0D: // Carriage return
                buffer.append("\\r");
                break;

            default:
                if ( c <= 0x1F ) {
                    buffer.append(String.format("\\u04x", c));
                } else {
                    buffer.appendCodePoint(c);
                }
            }
        }
        buffer.append('"');
    }

    /* Appends a value to the JSON flow. */
    private void addValue(Object value) {
        buffer.append(value.toString());
    }

    /* Closes a JSON dictionary. */
    private void endDict() {
        indentLevel -= 1;
        buffer.append('\n');
        buffer.append("  ".repeat(indentLevel));
        buffer.append("}");
    }

    /* Starts writing a JSON list. */
    private void startList() {
        buffer.append("[");
        indentLevel += 1;
        firstItem = true;
    }

    /* Appends a new item in a JSON list. */
    private void addItem() {
        if ( !firstItem ) {
            buffer.append(',');
        }
        buffer.append('\n');
        buffer.append("  ".repeat(indentLevel));
        firstItem = false;
    }

    /* Closes a JSON list. */
    private void endList() {
        indentLevel -= 1;
        buffer.append('\n');
        buffer.append("  ".repeat(indentLevel));
        buffer.append("]");
    }

    /*
     * Visit all slots in a mapping or mapping set to render their values in JSON.
     */
    private class SlotVisitor<T> extends SlotVisitorBase<T, Void> {

        @Override
        public Void visit(Slot<T> slot, T object, String value) {
            addKey(slot.getName());
            addValue(value);
            return null;
        }

        @Override
        public Void visit(Slot<T> slot, T object, List<String> values) {
            if ( values.size() > 0 ) {
                addKey(slot.getName());
                startList();
                for ( String value : values ) {
                    addItem();
                    addValue(value);
                }
                endList();
            }

            return null;
        }

        @Override
        public Void visit(Slot<T> slot, T object, Double value) {
            addKey(slot.getName());
            addValue(value);
            return null;
        }

        @Override
        public Void visit(Slot<T> slot, T object, LocalDate value) {
            addKey(slot.getName());
            addValue(value.format(DateTimeFormatter.ISO_DATE));
            return null;
        }

        @Override
        public Void visit(Slot<T> slot, T object, Object value) {
            addKey(slot.getName());
            addValue(value.toString());
            return null;
        }

        @Override
        public Void visitExtensionDefinitions(T object, List<ExtensionDefinition> definitions) {
            if ( extraPolicy == ExtraMetadataPolicy.DEFINED && !definitions.isEmpty() ) {
                addKey("extension_definitions");
                startList();
                for ( ExtensionDefinition definition : definitions ) {
                    addItem();
                    startDict();
                    addKey("slot_name");
                    addValue(definition.getSlotName());
                    addKey("property");
                    addValue(definition.getProperty());
                    if ( definition.getEffectiveType() != ValueType.STRING ) {
                        addKey("type_hint");
                        addValue(definition.getTypeHint());
                    }
                    endDict();
                }
                endList();
            }
            return null;
        }

        @Override
        public Void visitExtensions(T object, Map<String, ExtensionValue> extensions) {
            if ( extraPolicy != ExtraMetadataPolicy.NONE ) {
                for ( ExtensionDefinition definition : extensionManager.getDefinitions(true, false) ) {
                    ExtensionValue value = extensions.get(definition.getProperty());
                    if ( value != null ) {
                        addKey(definition.getSlotName());
                        switch ( value.getType() ) {
                        case BOOLEAN:
                            addValue(value.asBoolean());
                            break;
                        case DATE:
                            addValue(value.asDate().format(DateTimeFormatter.ISO_DATE));
                            break;
                        case DATETIME:
                            addValue(value.asDatetime().format(DateTimeFormatter.ISO_DATE_TIME));
                            break;
                        case DOUBLE:
                            addValue(value.asDouble());
                            break;
                        case INTEGER:
                            addValue(value.asInteger());
                            break;
                        default:
                            addValue(value.toString());
                            break;

                        }
                    }
                }
            }
            return null;
        }
    }
}
